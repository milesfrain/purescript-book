<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Foreign Function Interface - PureScript by Example</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect and Aff Monads</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter10.html" class="active"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Callback Hell</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-foreign-function-interface" id="the-foreign-function-interface">The Foreign Function Interface</a></h1>
<h2><a class="header" href="#chapter-goals" id="chapter-goals">Chapter Goals</a></h2>
<p>This chapter will introduce PureScript's <em>foreign function interface</em> (or <em>FFI</em>), which enables communication from PureScript code to JavaScript code, and vice versa. We will cover the following:</p>
<ul>
<li>How to call pure JavaScript functions from PureScript,</li>
<li>How to create new effect types and actions for use with the <code>Effect</code> monad, based on existing JavaScript code,</li>
<li>How to call PureScript code from JavaScript,</li>
<li>How to understand the representation of PureScript values at runtime,</li>
<li>How to work with untyped data using the <code>foreign</code> package.</li>
</ul>
<p>Towards the end of this chapter, we will revisit our recurring address book example. The goal of the chapter will be to add the following new functionality to our application using the FFI:</p>
<ul>
<li>Alerting the user with a popup notification,</li>
<li>Storing the serialized form data in the browser's local storage, and reloading it when the application restarts.</li>
</ul>
<h2><a class="header" href="#project-setup" id="project-setup">Project Setup</a></h2>
<p>The source code for this module is a continuation of the source code from chapters 3, 7 and 8. As such, the source tree includes the appropriate source files from those chapters.</p>
<p>This chapter intruduces the <code>foreign-generic</code> library as a dependency. This library adds support for <em>datatype generic programming</em> to the <code>foreign</code> library. The <code>foreign</code> library is a sub-dependency and provides a data type and functions for working with <em>untyped data</em>.</p>
<p><em>Note</em>: to avoid browser-specific issues with local storage when the webpage is served from a local file, it might be necessary to run this chapter's project over HTTP.</p>
<h2><a class="header" href="#a-disclaimer" id="a-disclaimer">A Disclaimer</a></h2>
<p>PureScript provides a straightforward foreign function interface to make working with JavaScript as simple as possible. However, it should be noted that the FFI is an <em>advanced</em> feature of the language. To use it safely and effectively, you should have an understanding of the runtime representation of the data you plan to work with. This chapter aims to impart such an understanding as pertains to code in PureScript's standard libraries.</p>
<p>PureScript's FFI is designed to be very flexible. In practice, this means that developers have a choice, between giving their foreign functions very simple types, or using the type system to protect against accidental misuses of foreign code. Code in the standard libraries tends to favor the latter approach.</p>
<p>As a simple example, a JavaScript function makes no guarantees that its return value will not be <code>null</code>. Indeed, idiomatic JavaScript code returns <code>null</code> quite frequently! However, PureScript's types are usually not inhabited by a null value. Therefore, it is the responsibility of the developer to handle these corner cases appropriately when designing their interfaces to JavaScript code using the FFI.</p>
<h2><a class="header" href="#calling-purescript-from-javascript" id="calling-purescript-from-javascript">Calling PureScript from JavaScript</a></h2>
<p>Calling a PureScript function from JavaScript is very simple, at least for functions with simple types.</p>
<p>Let's take the following simple module as an example:</p>
<pre><code class="language-haskell">module Test where

gcd :: Int -&gt; Int -&gt; Int
gcd 0 m = m
gcd n 0 = n
gcd n m
  | n &gt; m     = gcd (n - m) m
  | otherwise = gcd (m - n) n
</code></pre>
<p>This function finds the greatest common divisor of two numbers by repeated subtraction. It is a nice example of a case where you might like to use PureScript to define the function, but have a requirement to call it from JavaScript: it is simple to define this function in PureScript using pattern matching and recursion, and the implementor can benefit from the use of the type checker.</p>
<p>To understand how this function can be called from JavaScript, it is important to realize that PureScript functions always get turned into JavaScript functions of a single argument, so we need to apply its arguments one-by-one:</p>
<pre><code class="language-javascript">var Test = require('Test');
Test.gcd(15)(20);
</code></pre>
<p>Here, I am assuming that the code was compiled with <code>spago build</code>, which compiles PureScript modules to CommonJS modules. For that reason, I was able to reference the <code>gcd</code> function on the <code>Test</code> object, after importing the <code>Test</code> module using <code>require</code>.</p>
<p>You might also like to bundle JavaScript code for the browser, using <code>spago bundle-app --to file.js</code>. In that case, you would access the <code>Test</code> module from the global PureScript namespace, which defaults to <code>PS</code>:</p>
<pre><code class="language-javascript">var Test = PS.Test;
Test.gcd(15)(20);
</code></pre>
<h2><a class="header" href="#understanding-name-generation" id="understanding-name-generation">Understanding Name Generation</a></h2>
<p>PureScript aims to preserve names during code generation as much as possible. In particular, most identifiers which are neither PureScript nor JavaScript keywords can be expected to be preserved, at least for names of top-level declarations.</p>
<p>If you decide to use a JavaScript keyword as an identifier, the name will be escaped with a double dollar symbol. For example,</p>
<pre><code class="language-haskell">null = []
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var $$null = [];
</code></pre>
<p>In addition, if you would like to use special characters in your identifier names, they will be escaped using a single dollar symbol. For example,</p>
<pre><code class="language-haskell">example' = 100
</code></pre>
<p>generates the following JavaScript:</p>
<pre><code class="language-javascript">var example$prime = 100;
</code></pre>
<p>Where compiled PureScript code is intended to be called from JavaScript, it is recommended that identifiers only use alphanumeric characters, and avoid JavaScript keywords. If user-defined operators are provided for use in PureScript code, it is good practice to provide an alternative function with an alphanumeric name for use in JavaScript.</p>
<h2><a class="header" href="#runtime-data-representation" id="runtime-data-representation">Runtime Data Representation</a></h2>
<p>Types allow us to reason at compile-time that our programs are &quot;correct&quot; in some sense - that is, they will not break at runtime. But what does that mean? In PureScript, it means that the type of an expression should be compatible with its representation at runtime.</p>
<p>For that reason, it is important to understand the representation of data at runtime to be able to use PureScript and JavaScript code together effectively. This means that for any given PureScript expression, we should be able to understand the behavior of the value it will evaluate to at runtime.</p>
<p>The good news is that PureScript expressions have particularly simple representations at runtime. It should always be possible to understand the runtime data representation of an expression by considering its type.</p>
<p>For simple types, the correspondence is almost trivial. For example, if an expression has the type <code>Boolean</code>, then its value <code>v</code> at runtime should satisfy <code>typeof v === 'boolean'</code>. That is, expressions of type <code>Boolean</code> evaluate to one of the (JavaScript) values <code>true</code> or <code>false</code>. In particular, there is no PureScript expression of type <code>Boolean</code> which evaluates to <code>null</code> or <code>undefined</code>.</p>
<p>A similar law holds for expressions of type <code>Int</code> <code>Number</code> and <code>String</code> - expressions of type <code>Int</code> or <code>Number</code> evaluate to non-null JavaScript numbers, and expressions of type <code>String</code> evaluate to non-null JavaScript strings. Expressions of type <code>Int</code> will evaluate to integers at runtime, even though they cannot not be distinguished from values of type <code>Number</code> by using <code>typeof</code>.</p>
<p>What about some more complex types?</p>
<p>As we have already seen, PureScript functions correspond to JavaScript functions of a single argument. More precisely, if an expression <code>f</code> has type <code>a -&gt; b</code> for some types <code>a</code> and <code>b</code>, and an expression <code>x</code> evaluates to a value with the correct runtime representation for type <code>a</code>, then <code>f</code> evaluates to a JavaScript function, which when applied to the result of evaluating <code>x</code>, has the correct runtime representation for type <code>b</code>. As a simple example, an expression of type <code>String -&gt; String</code> evaluates to a function which takes non-null JavaScript strings to non-null JavaScript strings.</p>
<p>As you might expect, PureScript's arrays correspond to JavaScript arrays. But remember - PureScript arrays are homogeneous, so every element has the same type. Concretely, if a PureScript expression <code>e</code> has type <code>Array a</code> for some type <code>a</code>, then <code>e</code> evaluates to a (non-null) JavaScript array, all of whose elements have the correct runtime representation for type <code>a</code>.</p>
<p>We've already seen that PureScript's records evaluate to JavaScript objects. Just as for functions and arrays, we can reason about the runtime representation of data in a record's fields by considering the types associated with its labels. Of course, the fields of a record are not required to be of the same type.</p>
<h2><a class="header" href="#representing-adts" id="representing-adts">Representing ADTs</a></h2>
<p>For every constructor of an algebraic data type, the PureScript compiler creates a new JavaScript object type by defining a function. Its constructors correspond to functions which create new JavaScript objects based on those prototypes.</p>
<p>For example, consider the following simple ADT:</p>
<pre><code class="language-haskell">data ZeroOrOne a = Zero | One a
</code></pre>
<p>The PureScript compiler generates the following code:</p>
<pre><code class="language-javascript">function One(value0) {
    this.value0 = value0;
};

One.create = function (value0) {
    return new One(value0);
};

function Zero() {
};

Zero.value = new Zero();
</code></pre>
<p>Here, we see two JavaScript object types: <code>Zero</code> and <code>One</code>. It is possible to create values of each type by using JavaScript's <code>new</code> keyword. For constructors with arguments, the compiler stores the associated data in fields called <code>value0</code>, <code>value1</code>, etc.</p>
<p>The PureScript compiler also generates helper functions. For constructors with no arguments, the compiler generates a <code>value</code> property, which can be reused instead of using the <code>new</code> operator repeatedly. For constructors with one or more arguments, the compiler generates a <code>create</code> function, which takes arguments with the appropriate representation and applies the appropriate constructor.</p>
<p>What about constructors with more than one argument? In that case, the PureScript compiler also creates a new object type, and a helper function. This time, however, the helper function is curried function of two arguments. For example, this algebraic data type:</p>
<pre><code class="language-haskell">data Two a b = Two a b
</code></pre>
<p>generates this JavaScript code:</p>
<pre><code class="language-javascript">function Two(value0, value1) {
    this.value0 = value0;
    this.value1 = value1;
};

Two.create = function (value0) {
    return function (value1) {
        return new Two(value0, value1);
    };
};
</code></pre>
<p>Here, values of the object type <code>Two</code> can be created using the <code>new</code> keyword, or by using the <code>Two.create</code> function.</p>
<p>The case of newtypes is slightly different. Recall that a newtype is like an algebraic data type, restricted to having a single constructor taking a single argument. In this case, the runtime representation of the newtype is actually the same as the type of its argument.</p>
<p>For example, this newtype representing telephone numbers:</p>
<pre><code class="language-haskell">newtype PhoneNumber = PhoneNumber String
</code></pre>
<p>is actually represented as a JavaScript string at runtime. This is useful for designing libraries, since newtypes provide an additional layer of type safety, but without the runtime overhead of another function call.</p>
<h2><a class="header" href="#representing-quantified-types" id="representing-quantified-types">Representing Quantified Types</a></h2>
<p>Expressions with quantified (polymorphic) types have restrictive representations at runtime. In practice, this means that there are relatively few expressions with a given quantified type, but that we can reason about them quite effectively.</p>
<p>Consider this polymorphic type, for example:</p>
<pre><code class="language-haskell">forall a. a -&gt; a
</code></pre>
<p>What sort of functions have this type? Well, there is certainly one function with this type - namely, the <code>identity</code> function, defined in the <code>Prelude</code>:</p>
<pre><code class="language-haskell">id :: forall a. a -&gt; a
id a = a
</code></pre>
<p>In fact, the <code>identity</code> function is the <em>only</em> (total) function with this type! This certainly seems to be the case (try writing an expression with this type which is not observably equivalent to <code>identity</code>), but how can we be sure? We can be sure by considering the runtime representation of the type.</p>
<p>What is the runtime representation of a quantified type <code>forall a. t</code>? Well, any expression with the runtime representation for this type must have the correct runtime representation for the type <code>t</code> for any choice of type <code>a</code>. In our example above, a function of type <code>forall a. a -&gt; a</code> must have the correct runtime representation for the types <code>String -&gt; String</code>, <code>Number -&gt; Number</code>, <code>Array Boolean -&gt; Array Boolean</code>, and so on. It must take strings to strings, numbers to numbers, etc.</p>
<p>But that is not enough - the runtime representation of a quantified type is more strict than this. We require any expression to be <em>parametrically polymorphic</em> - that is, it cannot use any information about the type of its argument in its implementation. This additional condition prevents problematic implementations such as the following JavaScript function from inhabiting a polymorphic type:</p>
<pre><code class="language-javascript">function invalid(a) {
    if (typeof a === 'string') {
        return &quot;Argument was a string.&quot;;
    } else {
        return a;
    }
}
</code></pre>
<p>Certainly, this function takes strings to strings, numbers to numbers, etc. but it does not meet the additional condition, since it inspects the (runtime) type of its argument, so this function would not be a valid inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>Without being able to inspect the runtime type of our function argument, our only option is to return the argument unchanged, and so <code>identity</code> is indeed the only inhabitant of the type <code>forall a. a -&gt; a</code>.</p>
<p>A full discussion of <em>parametric polymorphism</em> and <em>parametricity</em> is beyond the scope of this book. Note however, that since PureScript's types are <em>erased</em> at runtime, a polymorphic function in PureScript <em>cannot</em> inspect the runtime representation of its arguments (without using the FFI), and so this representation of polymorphic data is appropriate.</p>
<h2><a class="header" href="#representing-constrained-types" id="representing-constrained-types">Representing Constrained Types</a></h2>
<p>Functions with a type class constraint have an interesting representation at runtime. Because the behavior of the function might depend on the type class instance chosen by the compiler, the function is given an additional argument, called a <em>type class dictionary</em>, which contains the implementation of the type class functions provided by the chosen instance.</p>
<p>For example, here is a simple PureScript function with a constrained type which uses the <code>Show</code> type class:</p>
<pre><code class="language-haskell">shout :: forall a. Show a =&gt; a -&gt; String
shout a = show a &lt;&gt; &quot;!!!&quot;
</code></pre>
<p>The generated JavaScript looks like this:</p>
<pre><code class="language-javascript">var shout = function (dict) {
    return function (a) {
        return show(dict)(a) + &quot;!!!&quot;;
    };
};
</code></pre>
<p>Notice that <code>shout</code> is compiled to a (curried) function of two arguments, not one. The first argument <code>dict</code> is the type class dictionary for the <code>Show</code> constraint. <code>dict</code> contains the implementation of the <code>show</code> function for the type <code>a</code>.</p>
<p>We can call this function from JavaScript by passing an explicit type class dictionary from <code>Data.Show</code> as the first parameter:</p>
<pre><code class="language-javascript">shout(require('Data.Show').showNumber)(42);
</code></pre>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<ol>
<li>
<p>(Easy) What are the runtime representations of these types?</p>
<pre><code class="language-haskell">forall a. a
forall a. a -&gt; a -&gt; a
forall a. Ord a =&gt; Array a -&gt; Boolean
</code></pre>
<p>What can you say about the expressions which have these types?</p>
</li>
<li>
<p>(Medium) Try using the functions defined in the <code>arrays</code> package, calling them from JavaScript, by compiling the library using <code>spago build</code> and importing modules using the <code>require</code> function in NodeJS. <em>Hint</em>: you may need to configure the output path so that the generated CommonJS modules are available on the NodeJS module path.</p>
</li>
</ol>
<h2><a class="header" href="#using-javascript-code-from-purescript" id="using-javascript-code-from-purescript">Using JavaScript Code From PureScript</a></h2>
<p>The simplest way to use JavaScript code from PureScript is to give a type to an existing JavaScript value using a <em>foreign import</em> declaration. Foreign import
declarations should have a corresponding JavaScript declaration in a <em>foreign JavaScript module</em>.</p>
<p>For example, consider the <code>encodeURIComponent</code> function, which can be used from JavaScript to encode a component of a URI by escaping special characters:</p>
<pre><code class="language-text">$ node

node&gt; encodeURIComponent('Hello World')
'Hello%20World'
</code></pre>
<p>This function has the correct runtime representation for the function type <code>String -&gt; String</code>, since it takes non-null strings to non-null strings, and has no other side-effects.</p>
<p>We can assign this type to the function with the following foreign import declaration:</p>
<pre><code class="language-haskell">module Data.URI where

foreign import encodeURIComponent :: String -&gt; String
</code></pre>
<p>We also need to write a foreign JavaScript module. If the module above is saved as <code>src/Data/URI.purs</code>, then the foreign JavaScript module should be saved as
<code>src/Data/URI.js</code>:</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

exports.encodeURIComponent = encodeURIComponent;
</code></pre>
<p>Spago will find <code>.js</code> files in the <code>src</code> directory, and provide them to the compiler as foreign JavaScript modules.</p>
<p>JavaScript functions and values are exported from foreign JavaScript modules by assigning them to the <code>exports</code> object just like a regular CommonJS module. The <code>purs</code> compiler treats this module like a regular CommonJS module, and simply adds it as a dependency to the compiled
PureScript module. However, when bundling code for the browser with <code>psc-bundle</code> or <code>spago bundle-app --to</code>, it is very important to follow the
pattern above, assigning exports to the <code>exports</code> object using a property assignment. This is because <code>psc-bundle</code> recognizes this format,
allowing unused JavaScript exports to be removed from bundled code.</p>
<p>With these two pieces in place, we can now use the <code>encodeURIComponent</code> function from PureScript like any function written in PureScript.
For example, if this declaration is saved as a module and loaded into PSCi, we can reproduce the calculation above:</p>
<pre><code class="language-text">$ spago repl

&gt; import Data.URI
&gt; encodeURIComponent &quot;Hello World&quot;
&quot;Hello%20World&quot;
</code></pre>
<p>This approach works well for simple JavaScript values, but is of limited use for more complicated examples. The reason is that most idiomatic JavaScript code does not meet the strict criteria imposed by the runtime representations of the basic PureScript types. In those cases, we have another option - we can <em>wrap</em> the JavaScript code in such a way that we can force it to adhere to the correct runtime representation.</p>
<h2><a class="header" href="#wrapping-javascript-values" id="wrapping-javascript-values">Wrapping JavaScript Values</a></h2>
<p>We might want to wrap JavaScript values and functions for a number of reasons:</p>
<ul>
<li>A function takes multiple arguments, but we want to call it like a curried function.</li>
<li>We might want to use the <code>Effect</code> monad to keep track of any JavaScript side-effects.</li>
<li>It might be necessary to handle corner cases like <code>null</code> or <code>undefined</code>, to give a function the correct runtime representation.</li>
</ul>
<p>For example, suppose we wanted to recreate the <code>head</code> function on arrays by using a foreign declaration. In JavaScript, we might write the function as follows:</p>
<pre><code class="language-javascript">function head(arr) {
    return arr[0];
}
</code></pre>
<p>However, there is a problem with this function. We might try to give it the type <code>forall a. Array a -&gt; a</code>, but for empty arrays, this function returns <code>undefined</code>. Therefore, this function does not have the correct runtime representation, and we should use a wrapper function to handle this corner case.</p>
<p>To keep things simple, we can throw an exception in the case of an empty array. Strictly speaking, pure functions should not throw exceptions, but it will suffice for demonstration purposes, and we can indicate the lack of safety in the function name:</p>
<pre><code class="language-haskell">foreign import unsafeHead :: forall a. Array a -&gt; a
</code></pre>
<p>In our foreign JavaScript module, we can define <code>unsafeHead</code> as follows:</p>
<pre><code class="language-javascript">exports.unsafeHead = function(arr) {
  if (arr.length) {
    return arr[0];
  } else {
    throw new Error('unsafeHead: empty array');
  }
};
</code></pre>
<h2><a class="header" href="#defining-foreign-types" id="defining-foreign-types">Defining Foreign Types</a></h2>
<p>Throwing an exception in the case of failure is less than ideal - idiomatic PureScript code uses the type system to represent side-effects such as missing values. One example of this approach is the <code>Maybe</code> type constructor. In this section, we will build another solution using the FFI.</p>
<p>Suppose we wanted to define a new type <code>Undefined a</code> whose representation at runtime was like that for the type <code>a</code>, but also allowing the <code>undefined</code> value.</p>
<p>We can define a <em>foreign type</em> using the FFI using a <em>foreign type declaration</em>. The syntax is similar to defining a foreign function:</p>
<pre><code class="language-haskell">foreign import data Undefined :: Type -&gt; Type
</code></pre>
<p>Note that the <code>data</code> keyword here indicates that we are defining a type, not a value. Instead of a type signature, we give the <em>kind</em> of the new type. In this case, we declare the kind of <code>Undefined</code> to be <code>Type -&gt; Type</code>. In other words, <code>Undefined</code> is a type constructor.</p>
<p>We can now simplify our original definition for <code>head</code>:</p>
<pre><code class="language-javascript">exports.head = function(arr) {
  return arr[0];
};
</code></pre>
<p>And in the PureScript module:</p>
<pre><code class="language-haskell">foreign import head :: forall a. Array a -&gt; Undefined a
</code></pre>
<p>Note the two changes: the body of the <code>head</code> function is now much simpler, and returns <code>arr[0]</code> even if that value is undefined, and the type signature has been changed to reflect the fact that our function can return an undefined value.</p>
<p>This function has the correct runtime representation for its type, but is quite useless since we have no way to use a value of type <code>Undefined a</code>. But we can fix that by writing some new functions using the FFI!</p>
<p>The most basic function we need will tell us whether a value is defined or not:</p>
<pre><code class="language-haskell">foreign import isUndefined :: forall a. Undefined a -&gt; Boolean
</code></pre>
<p>This is easily defined in our foreign JavaScript module as follows:</p>
<pre><code class="language-javascript">exports.isUndefined = function(value) {
  return value === undefined;
};
</code></pre>
<p>We can now use <code>isUndefined</code> and <code>head</code> together from PureScript to define a useful function:</p>
<pre><code class="language-haskell">isEmpty :: forall a. Array a -&gt; Boolean
isEmpty = isUndefined &lt;&lt;&lt; head
</code></pre>
<p>Here, the foreign functions we defined were very simple, which meant that we were able to benefit from the use of PureScript's typechecker as much as possible. This is good practice in general: foreign functions should be kept as small as possible, and application logic moved into PureScript code wherever possible.</p>
<h2><a class="header" href="#functions-of-multiple-arguments" id="functions-of-multiple-arguments">Functions of Multiple Arguments</a></h2>
<p>PureScript's Prelude contains an interesting set of examples of foreign types. As we have covered already, PureScript's function types only take a single argument, and can be used to simulate functions of multiple arguments via <em>currying</em>. This has certain advantages - we can partially apply functions, and give type class instances for function types - but it comes with a performance penalty. For performance critical code, it is sometimes necessary to define genuine JavaScript functions which accept multiple arguments. The Prelude defines foreign types which allow us to work safely with such functions.</p>
<p>For example, the following foreign type declaration is taken from the Prelude in the <code>Data.Function.Uncurried</code> module:</p>
<pre><code class="language-haskell">foreign import data Fn2 :: Type -&gt; Type -&gt; Type -&gt; Type
</code></pre>
<p>This defines the type constructor <code>Fn2</code> which takes three type arguments. <code>Fn2 a b c</code> is a type representing JavaScript functions of two arguments of types <code>a</code> and <code>b</code>, and with return type <code>c</code>.</p>
<p>The <code>functions</code> package defines similar type constructors for function arities from 0 to 10.</p>
<p>We can create a function of two arguments by using the <code>mkFn2</code> function, as follows:</p>
<pre><code class="language-haskell">import Data.Function.Uncurried

uncurriedAdd :: Fn2 Int Int Int
uncurriedAdd = mkFn2 \n m -&gt; m + n
</code></pre>
<p>and we can apply a function of two arguments by using the <code>runFn2</code> function:</p>
<pre><code class="language-haskell">&gt; runFn2 uncurriedAdd 3 10
13
</code></pre>
<p>The key here is that the compiler <em>inlines</em> the <code>mkFn2</code> and <code>runFn2</code> functions whenever they are fully applied. The result is that the generated code is very compact:</p>
<pre><code class="language-javascript">var uncurriedAdd = function (n, m) {
    return m + n | 0;
};
</code></pre>
<p>For contrast, here is a traditional curried function:</p>
<pre><code class="language-haskell">curriedAdd :: Int -&gt; Int -&gt; Int
curriedAdd n m = m + n
</code></pre>
<p>and the resulting generated code, which is less compact due to the nested functions:</p>
<pre><code class="language-javascript">var curriedAdd = function (n) {
    return function (m) {
        return m + n | 0;
    };
};
</code></pre>
<h2><a class="header" href="#representing-side-effects" id="representing-side-effects">Representing Side Effects</a></h2>
<p>The <code>Effect</code> monad is also defined as a foreign type. Its runtime representation is quite simple - an expression of type <code>Effect a</code> should evaluate to a JavaScript function of no arguments, which performs any side-effects and returns a value with the correct runtime representation for type <code>a</code>.</p>
<p>The definition of the <code>Effect</code> type constructor is given in the <code>Effect</code> module as follows:</p>
<pre><code class="language-haskell">foreign import data Effect :: Type -&gt; Type
</code></pre>
<p>As a simple example, consider the <code>random</code> function defined in the <code>random</code> package. Recall that its type was:</p>
<pre><code class="language-haskell">foreign import random :: Effect Number
</code></pre>
<p>The definition of the <code>random</code> function is given here:</p>
<pre><code class="language-javascript">exports.random = Math.random;
</code></pre>
<p>Notice that the <code>random</code> function is represented at runtime as a function of no arguments. It performs the side effect of generating a random number, and returns it, and the return value matches the runtime representation of the <code>Number</code> type: it is a non-null JavaScript number.</p>
<p>As a slightly more interesting example, consider the <code>log</code> function defined by the <code>Effect.Console</code> module in the <code>console</code> package. The <code>log</code> function has the following type:</p>
<pre><code class="language-haskell">foreign import log :: String -&gt; Effect Unit
</code></pre>
<p>And here is its definition:</p>
<pre><code class="language-javascript">exports.log = function (s) {
  return function () {
    console.log(s);
  };
};
</code></pre>
<p>The representation of <code>log</code> at runtime is a JavaScript function of a single argument, returning a function of no arguments. The inner function performs the side-effect of writing a message to the console.</p>
<p>Expressions of type <code>Effect a</code> can be invoked from JavaScript like regular JavaScript methods. For example, since the <code>main</code> function is required to have type <code>Effect a</code> for some type <code>a</code>, it can be invoked as follows:</p>
<pre><code class="language-javascript">require('Main').main();
</code></pre>
<p>When using <code>spago bundle-app --to</code> or <code>spago run</code>, this call to <code>main</code> is generated automatically, whenever the <code>Main</code> module is defined.</p>
<h2><a class="header" href="#defining-new-effects" id="defining-new-effects">Defining New Effects</a></h2>
<p>The source code for this chapter defines two new effects. The simplest is <code>alert</code>, defined in the <code>Effect.Alert</code> module. It is used to indicate that a computation might alert the user using a popup window.</p>
<p>The effect is defined using a foreign type declaration:</p>
<pre><code class="language-haskell">foreign import alert :: String -&gt; Effect Unit
</code></pre>
<p>The foreign JavaScript module is straightforward, defining the <code>alert</code> function by assigning it to the <code>exports</code> variable:</p>
<pre><code class="language-javascript">&quot;use strict&quot;;

exports.alert = function(msg) {
    return function() {
        window.alert(msg);
    };
};

</code></pre>
<p>The <code>alert</code> action is very similar to the <code>log</code> action from the <code>Effect.Console</code> module. The only difference is that the <code>alert</code> action uses the <code>window.alert</code> method, whereas the <code>log</code> action uses the <code>console.log</code> method. As such, <code>alert</code> can only be used in environments where <code>window.alert</code> is defined, such as a web browser.</p>
<p>Note that, as in the case of <code>log</code>, the <code>alert</code> function uses a function of no arguments to represent the computation of type <code>Effect Unit</code>.</p>
<p>The second effect defined in this chapter is the <code>Storage</code> effect, which is defined in the <code>Effect.Storage</code> module. It is used to indicate that a computation might read or write values using the Web Storage API.</p>
<p>The <code>Effect.Storage</code> module defines two actions: <code>getItem</code>, which retrieves a value from local storage, and <code>setItem</code> which inserts or updates a value in local storage. The two functions have the following types:</p>
<pre><code class="language-haskell">foreign import getItem :: String -&gt; Effect Foreign

foreign import setItem :: String -&gt; String -&gt; Effect Unit
</code></pre>
<p>The interested reader can inspect the source code for this module to see the definitions of these actions.</p>
<p><code>setItem</code> takes a key and a value (both strings), and returns a computation which stores the value in local storage at the specified key.</p>
<p>The type of <code>getItem</code> is more interesting. It takes a key, and attempts to retrieve the associated value from local storage. However, since the <code>getItem</code> method on <code>window.localStorage</code> can return <code>null</code>, the return type is not <code>String</code>, but <code>Foreign</code> which is defined by the <code>foreign</code> package in the <code>Foreign</code> module.</p>
<p><code>Foreign</code> provides a way to work with <em>untyped data</em>, or more generally, data whose runtime representation is uncertain.</p>
<h2><a class="header" href="#exercises-1" id="exercises-1">Exercises</a></h2>
<ol>
<li>(Medium) Write a wrapper for the <code>confirm</code> method on the JavaScript <code>Window</code> object, and add your foreign function to the <code>Effect.Alert</code> module.</li>
<li>(Medium) Write a wrapper for the <code>removeItem</code> method on the <code>localStorage</code> object, and add your foreign function to the <code>Effect.Storage</code> module.</li>
</ol>
<h2><a class="header" href="#working-with-untyped-data" id="working-with-untyped-data">Working With Untyped Data</a></h2>
<p>In this section, we will see how we can use the <code>Foreign</code> library to turn untyped data into typed data, with the correct runtime representation for its type.</p>
<p>The code for this chapter demonstrates how a record can be serialized to JSON and stored in / retrieved from local storage.</p>
<p>The <code>Main</code> module defines a type for the saved form data:</p>
<pre><code class="language-haskell">newtype FormData = FormData
  { firstName  :: String
  , lastName   :: String
  }
</code></pre>
<p>The problem is that we have no guarantee that the JSON will have the correct form. Put another way, we don't know that the JSON represents the correct type of data at runtime. This is the sort of problem that is solved by the <code>foreign</code> library. Here are some other examples:</p>
<ul>
<li>A JSON response from a web service</li>
<li>A value passed to a function from JavaScript code</li>
</ul>
<p>Let's try the <code>foreign</code> and <code>foreign-generic</code> libraries in PSCi.</p>
<p>Start by importing some modules:</p>
<pre><code class="language-text">&gt; import Foreign
&gt; import Foreign.Generic
&gt; import Foreign.JSON
</code></pre>
<p>A good way to obtain a <code>Foreign</code> value is to parse a JSON document. <code>foreign-generic</code> defines the following two functions:</p>
<pre><code class="language-haskell">parseJSON :: String -&gt; F Foreign
decodeJSON :: forall a. Decode a =&gt; String -&gt; F a
</code></pre>
<p>The type constructor <code>F</code> is actually just a type synonym, defined in <code>Foreign</code>:</p>
<pre><code class="language-haskell">type F = Except MultipleErrors
</code></pre>
<p>Here, <code>Except</code> is a monad for handling exceptions in pure code, much like <code>Either</code>. We can convert a value in the <code>F</code> monad into a value in the <code>Either</code> monad by using the <code>runExcept</code> function.</p>
<p>Most of the functions in the <code>foreign</code> and <code>foreign-generic</code> libraries return a value in the <code>F</code> monad, which means that we can use do notation and the applicative functor combinators to build typed values.</p>
<p>The <code>Decode</code> type class represents those types which can be obtained from untyped data. There are type class instances defined for the primitive types and arrays, and we can define our own instances as well.</p>
<p>Let's try parsing some simple JSON documents using <code>decodeJSON</code> in PSCi (remembering to use <code>runExcept</code> to unwrap the results):</p>
<pre><code class="language-text">&gt; import Control.Monad.Except

&gt; runExcept (decodeJSON &quot;\&quot;Testing\&quot;&quot; :: F String)
Right &quot;Testing&quot;

&gt; runExcept (decodeJSON &quot;true&quot; :: F Boolean)
Right true

&gt; runExcept (decodeJSON &quot;[1, 2, 3]&quot; :: F (Array Int))
Right [1, 2, 3]
</code></pre>
<p>Recall that in the <code>Either</code> monad, the <code>Right</code> data constructor indicates success. Note however, that invalid JSON, or an incorrect type leads to an error:</p>
<pre><code class="language-text">&gt; runExcept (decodeJSON &quot;[1, 2, true]&quot; :: F (Array Int))
(Left (NonEmptyList (NonEmpty (ErrorAtIndex 2 (TypeMismatch &quot;Int&quot; &quot;Boolean&quot;)) Nil)))
</code></pre>
<p>The <code>foreign-generic</code> library tells us where in the JSON document the type error occurred.</p>
<h2><a class="header" href="#handling-null-and-undefined-values" id="handling-null-and-undefined-values">Handling Null and Undefined Values</a></h2>
<p>Real-world JSON documents contain null and undefined values, so we need to be able to handle those too. <code>foreign-generic</code> solves this problem with the 'Maybe' type constructor to represent missing values.</p>
<pre><code class="language-text">&gt; import Prelude
&gt; import Foreign.NullOrUndefined

&gt; runExcept (decodeJSON &quot;42&quot; :: F (Maybe Int))
(Right (Just 42))

&gt; runExcept (decodeJSON &quot;null&quot; :: F (Maybe Int))
(Right Nothing)
</code></pre>
<p>The type <code>Maybe Int</code> represents values which are either integers, or null. What if we wanted to parse more interesting values, like arrays of integers, where each element might be <code>null</code>? <code>decodeJSON</code> handles such cases as well:</p>
<pre><code class="language-text">&gt; runExcept (decodeJSON &quot;[1,2,null]&quot; :: F (Array (Maybe Int)))
(Right [(Just 1),(Just 2),Nothing])
</code></pre>
<h2><a class="header" href="#generic-json-serialization" id="generic-json-serialization">Generic JSON Serialization</a></h2>
<p>In fact, we rarely need to write instances for the <code>Decode</code> class, since the <code>foreign-generic</code> class allows us to <em>derive</em> instances using a technique called <em>datatype-generic programming</em>. A full explanation of this technique is beyond the scope of this book, but it allows us to write functions once, and reuse them over many different data types, based on the structure of a the types themselves.</p>
<p>To derive a <code>Decode</code> instance for our <code>FormData</code> type (so that we may deserialize it from its JSON representation), we first use the <code>derive</code> keyword to derive an instance of the <code>Generic</code> type class, which looks like this:</p>
<pre><code class="language-haskell">import Data.Generic.Rep
derive instance genericFormData :: Generic FormData _
</code></pre>
<p>Next, we simply define the <code>decode</code> function using the <code>genericDecode</code> function, as follows:</p>
<pre><code class="language-haskell">import Foreign.Class
instance decodeFormData :: Decode FormData where
  decode = genericDecode (defaultOptions { unwrapSingleConstructors = true })
</code></pre>
<p>In fact, we can also derive an <em>encoder</em> in the same way:</p>
<pre><code class="language-haskell">instance encodeFormData :: Encode FormData where
  encode = genericEncode (defaultOptions { unwrapSingleConstructors = true })
</code></pre>
<p>And even an instance of Show which comes in handy for logging the result:</p>
<pre><code class="language-haskell">instance showFormData :: Show FormData where
  show = genericShow
</code></pre>
<p>It is important that we use the same options in the decoder and encoder, otherwise our encoded JSON documents might not get decoded correctly.</p>
<p>Now, in our main function, a value of type <code>FormData</code> is passed to the <code>encode</code> function, serializing it as a JSON document. The <code>FormData</code> type is a newtype for a record, so a value of type <code>FormData</code> passed to <code>encode</code> will be serialized as a JSON <em>object</em>. This is because we used the <code>unwrapSingleConstructors</code> option when defining our JSON encoder.</p>
<p>Our <code>Decode</code> type class instance is used with <code>decodeJSON</code> to parse the JSON document when it is retrieved from local storage, as follows:</p>
<pre><code class="language-haskell">loadSavedData = do
  item &lt;- getItem &quot;person&quot;

  let
    savedData :: Either (NonEmptyList ForeignError) (Maybe FormData)
    savedData = runExcept do
      jsonOrNull &lt;- traverse readString =&lt;&lt; readNullOrUndefined item
      traverse decodeJSON jsonOrNull
</code></pre>
<p>The <code>savedData</code> action reads the <code>FormData</code> structure in two steps: first, it parses the <code>Foreign</code> value obtained from <code>getItem</code>. The type of <code>jsonOrNull</code> is inferred by the compiler to be <code>Maybe String</code> (exercise for the reader - how is this type inferred?). The <code>traverse</code> function is then used to apply <code>decodeJSON</code> to the (possibly missing) element of the result of type <code>Maybe String</code>. The type class instance inferred for <code>decodeJSON</code> is the one we just wrote, resulting in a value of type <code>F (Maybe FormData)</code>.</p>
<p>We need to use the monadic structure of <code>F</code>, since the argument to <code>traverse</code> uses the result <code>jsonOrNull</code> obtained in the first line.</p>
<p>There are three possibilities for the result of <code>FormData</code>:</p>
<ul>
<li>If the outer constructor is <code>Left</code>, then there was an error parsing the JSON string, or it represented a value of the wrong type. In this case, the application displays an error using the <code>alert</code> action we wrote earlier.</li>
<li>If the outer constructor is <code>Right</code>, but the inner constructor is <code>Nothing</code>, then <code>getItem</code> also returned <code>Nothing</code> which means that the key did not exist in local storage. In this case, the application continues quietly.</li>
<li>Finally, a value matching the pattern <code>Right (Just _)</code> indicates a successfully parsed JSON document. In this case, the application updates the form fields with the appropriate values.</li>
</ul>
<p>Try out the code, by running <code>spago bundle-app --to dist/Main.js</code>, and then opening the browser to <code>html/index.html</code>. You should be able to see what's going on in the console.</p>
<p><em>Note</em>: You may need to serve the HTML and JavaScript files from a HTTP server locally in order to avoid certain browser-specific issues.</p>
<h2><a class="header" href="#exercises-2" id="exercises-2">Exercises</a></h2>
<ol>
<li>
<p>(Easy) Use <code>decodeJSON</code> to parse a JSON document representing a two-dimensional JavaScript array of integers, such as <code>[[1, 2, 3], [4, 5], [6]]</code>. What if the elements are allowed to be null? What if the arrays themselves are allowed to be null?</p>
</li>
<li>
<p>(Medium) Convince yourself that the implementation of <code>savedData</code> should type-check, and write down the inferred types of each subexpression in the computation.</p>
</li>
<li>
<p>(Medium) The following data type represents a binary tree with values at the leaves:</p>
<pre><code class="language-haskell">data Tree a = Leaf a | Branch (Tree a) (Tree a)
</code></pre>
<p>Derive <code>Encode</code> and <code>Decode</code> instances for this type using <code>foreign-generic</code>, and verify that encoded values can correctly be decoded in PSCi. Hint: This requires a <a href="https://github.com/paf31/24-days-of-purescript-2016/blob/master/11.markdown#deriving-generic-instances">Generic Instance</a>, also see previous section on &quot;Instance Dependencies&quot;, and finally, search the web for &quot;eta-expansion&quot; if you encounter recursion issues during testing.</p>
</li>
<li>
<p>(Difficult) The following <code>data</code> type should be represented directly in JSON as either an integer or a string:</p>
<pre><code class="language-haskell">data IntOrString
  = IntOrString_Int Int
  | IntOrString_String String
</code></pre>
<p>Write instances for <code>Encode</code> and <code>Decode</code> for the <code>IntOrString</code> data type which implement this behavior, and verify that encoded values can correctly be decoded in PSCi.</p>
</li>
</ol>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>In this chapter, we've learned how to work with foreign JavaScript code from PureScript, and vice versa, and we've seen the issues involved with writing trustworthy code using the FFI:</p>
<ul>
<li>We've seen the importance of the <em>runtime representation</em> of data, and ensuring that foreign functions have the correct representation.</li>
<li>We learned how to deal with corner cases like null values and other types of JavaScript data, by using foreign types, or the <code>Foreign</code> data type.</li>
<li>We looked at some common foreign types defined in the Prelude, and how they can be used to interoperate with idiomatic JavaScript code. In particular, the representation of side-effects in the <code>Effect</code> monad was introduced, and we saw how to use the <code>Effect</code> monad to capture new side effects.</li>
<li>We saw how to safely deserialize JSON data using the <code>Decode</code> type class.</li>
</ul>
<p>For more examples, the <code>purescript</code>, <code>purescript-contrib</code> and <code>purescript-node</code> GitHub organizations provide plenty of examples of libraries which use the FFI. In the remaining chapters, we will see some of these libraries put to use to solve real-world problems in a type-safe way.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter9.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter9.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
