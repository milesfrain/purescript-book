<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Applicative Validation - PureScript by Example</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Functions and Records</a></li><li class="chapter-item expanded "><a href="chapter4.html"><strong aria-hidden="true">4.</strong> Recursion, Maps And Folds</a></li><li class="chapter-item expanded "><a href="chapter5.html"><strong aria-hidden="true">5.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="chapter6.html"><strong aria-hidden="true">6.</strong> Type Classes</a></li><li class="chapter-item expanded "><a href="chapter7.html" class="active"><strong aria-hidden="true">7.</strong> Applicative Validation</a></li><li class="chapter-item expanded "><a href="chapter8.html"><strong aria-hidden="true">8.</strong> The Effect and Aff Monads</a></li><li class="chapter-item expanded "><a href="chapter9.html"><strong aria-hidden="true">9.</strong> Canvas Graphics</a></li><li class="chapter-item expanded "><a href="chapter10.html"><strong aria-hidden="true">10.</strong> The Foreign Function Interface</a></li><li class="chapter-item expanded "><a href="chapter11.html"><strong aria-hidden="true">11.</strong> Monadic Adventures</a></li><li class="chapter-item expanded "><a href="chapter12.html"><strong aria-hidden="true">12.</strong> Callback Hell</a></li><li class="chapter-item expanded "><a href="chapter13.html"><strong aria-hidden="true">13.</strong> Generative Testing</a></li><li class="chapter-item expanded "><a href="chapter14.html"><strong aria-hidden="true">14.</strong> Domain-Specific Languages</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">PureScript by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#applicative-validation" id="applicative-validation">Applicative Validation</a></h1>
<h2><a class="header" href="#chapter-goals" id="chapter-goals">Chapter Goals</a></h2>
<p>In this chapter, we will meet an important new abstraction - the <em>applicative functor</em>, described by the <code>Applicative</code> type class. Don't worry if the name sounds confusing - we will motivate the concept with a practical example - validating form data. This technique allows us to convert code which usually involves a lot of boilerplate checking into a simple, declarative description of our form.</p>
<p>We will also meet another type class, <code>Traversable</code>, which describes <em>traversable functors</em>, and see how this concept also arises very naturally from solutions to real-world problems.</p>
<p>The example code for this chapter will be a continuation of the address book example from chapter 3. This time, we will extend our address book data types, and write functions to validate values for those types. The understanding is that these functions could be used, for example in a web user interface, to display errors to the user as part of a data entry form.</p>
<h2><a class="header" href="#project-setup" id="project-setup">Project Setup</a></h2>
<p>The source code for this chapter is defined in the files <code>src/Data/AddressBook.purs</code> and <code>src/Data/AddressBook/Validation.purs</code>.</p>
<p>The project has a number of dependencies, many of which we have seen before. There are two new dependencies:</p>
<ul>
<li><code>control</code>, which defines functions for abstracting control flow using type classes like <code>Applicative</code>.</li>
<li><code>validation</code>, which defines a functor for <em>applicative validation</em>, the subject of this chapter.</li>
</ul>
<p>The <code>Data.AddressBook</code> module defines data types and <code>Show</code> instances for the types in our project, and the <code>Data.AddressBook.Validation</code> module contains validation rules for those types.</p>
<h2><a class="header" href="#generalizing-function-application" id="generalizing-function-application">Generalizing Function Application</a></h2>
<p>To explain the concept of an <em>applicative functor</em>, let's consider the type constructor <code>Maybe</code> that we met earlier.</p>
<p>The source code for this module defines a function <code>address</code> which has the following type:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address
</code></pre>
<p>This function is used to construct a value of type <code>Address</code> from three strings: a street name, a city, and a state.</p>
<p>We can apply this function easily and see the result in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; address &quot;123 Fake St.&quot; &quot;Faketown&quot; &quot;CA&quot;
Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; }
</code></pre>
<p>However, suppose we did not necessarily have a street, city, or state, and wanted to use the <code>Maybe</code> type to indicate a missing value in each of the three cases.</p>
<p>In one case, we might have a missing city. If we try to apply our function directly, we will receive an error from the type checker:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Could not match type

  Maybe String

with type

  String
</code></pre>
<p>Of course, this is an expected type error - <code>address</code> takes strings as arguments, not values of type <code>Maybe String</code>.</p>
<p>However, it is reasonable to expect that we should be able to &quot;lift&quot; the <code>address</code> function to work with optional values described by the <code>Maybe</code> type. In fact, we can, and the <code>Control.Apply</code> provides the function <code>lift3</code> function which does exactly what we need:</p>
<pre><code class="language-text">&gt; import Control.Apply
&gt; lift3 address (Just &quot;123 Fake St.&quot;) Nothing (Just &quot;CA&quot;)

Nothing
</code></pre>
<p>In this case, the result is <code>Nothing</code>, because one of the arguments (the city) was missing. If we provide all three arguments using the <code>Just</code> constructor, then the result will contain a value as well:</p>
<pre><code class="language-text">&gt; lift3 address (Just &quot;123 Fake St.&quot;) (Just &quot;Faketown&quot;) (Just &quot;CA&quot;)

Just (Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })
</code></pre>
<p>The name of the function <code>lift3</code> indicates that it can be used to lift functions of 3 arguments. There are similar functions defined in <code>Control.Apply</code> for functions of other numbers of arguments.</p>
<h2><a class="header" href="#lifting-arbitrary-functions" id="lifting-arbitrary-functions">Lifting Arbitrary Functions</a></h2>
<p>So, we can lift functions with small numbers of arguments by using <code>lift2</code>, <code>lift3</code>, etc. But how can we generalize this to arbitrary functions?</p>
<p>It is instructive to look at the type of <code>lift3</code>:</p>
<pre><code class="language-text">&gt; :type lift3
forall a b c d f. Apply f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d
</code></pre>
<p>In the <code>Maybe</code> example above, the type constructor <code>f</code> is <code>Maybe</code>, so that <code>lift3</code> is specialized to the following type:</p>
<pre><code class="language-haskell">forall a b c d. (a -&gt; b -&gt; c -&gt; d) -&gt; Maybe a -&gt; Maybe b -&gt; Maybe c -&gt; Maybe d
</code></pre>
<p>This type says that we can take any function with three arguments, and lift it to give a new function whose argument and result types are wrapped with <code>Maybe</code>.</p>
<p>Certainly, this is not possible for any type constructor <code>f</code>, so what is it about the <code>Maybe</code> type which allowed us to do this? Well, in specializing the type above, we removed a type class constraint on <code>f</code> from the <code>Apply</code> type class. <code>Apply</code> is defined in the Prelude as follows:</p>
<pre><code class="language-haskell">class Functor f where
  map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b

class Functor f &lt;= Apply f where
  apply :: forall a b. f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>The <code>Apply</code> type class is a subclass of <code>Functor</code>, and defines an additional function <code>apply</code>. As <code>&lt;$&gt;</code> was defined as an alias for <code>map</code>, the <code>Prelude</code> module defines <code>&lt;*&gt;</code> as an alias for <code>apply</code>. As we'll see, these two operators are often used together.</p>
<p>The type of <code>apply</code> looks a lot like the type of <code>map</code>. The difference between <code>map</code> and <code>apply</code> is that <code>map</code> takes a function as an argument, whereas the first argument to <code>apply</code> is wrapped in the type constructor <code>f</code>. We'll see how this is used soon, but first, let's see how to implement the <code>Apply</code> type class for the <code>Maybe</code> type:</p>
<pre><code class="language-haskell">instance functorMaybe :: Functor Maybe where
  map f (Just a) = Just (f a)
  map f Nothing  = Nothing

instance applyMaybe :: Apply Maybe where
  apply (Just f) (Just x) = Just (f x)
  apply _        _        = Nothing
</code></pre>
<p>This type class instance says that we can apply an optional function to an optional value, and the result is defined only if both are defined.</p>
<p>Now we'll see how <code>map</code> and <code>apply</code> can be used together to lift functions of arbitrary number of arguments.</p>
<p>For functions of one argument, we can just use <code>map</code> directly.</p>
<p>For functions of two arguments, we have a curried function <code>g</code> with type <code>a -&gt; b -&gt; c</code>, say. This is equivalent to the type <code>a -&gt; (b -&gt; c)</code>, so we can apply <code>map</code> to <code>g</code> to get a new function of type <code>f a -&gt; f (b -&gt; c)</code> for any type constructor <code>f</code> with a <code>Functor</code> instance. Partially applying this function to the first lifted argument (of type <code>f a</code>), we get a new wrapped function of type <code>f (b -&gt; c)</code>. If we also have an <code>Apply</code> instance for <code>f</code>, then we can then use <code>apply</code> to apply the second lifted argument (of type <code>f b</code>) to get our final value of type <code>f c</code>.</p>
<p>Putting this all together, we see that if we have values <code>x :: f a</code> and <code>y :: f b</code>, then the expression <code>(g &lt;$&gt; x) &lt;*&gt; y</code> has type <code>f c</code> (remember, this expression is equivalent to <code>apply (map g x) y</code>). The precedence rules defined in the Prelude allow us to remove the parentheses: <code>g &lt;$&gt; x &lt;*&gt; y</code>.</p>
<p>In general, we can use <code>&lt;$&gt;</code> on the first argument, and <code>&lt;*&gt;</code> for the remaining arguments, as illustrated here for <code>lift3</code>:</p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z
</code></pre>
<p>It is left as an exercise for the reader to verify the types involved in this expression.</p>
<p>As an example, we can try lifting the address function over <code>Maybe</code>, directly using the <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> functions:</p>
<pre><code class="language-text">&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Just &quot;Faketown&quot; &lt;*&gt; Just &quot;CA&quot;
Just (Address { street: &quot;123 Fake St.&quot;, city: &quot;Faketown&quot;, state: &quot;CA&quot; })

&gt; address &lt;$&gt; Just &quot;123 Fake St.&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;CA&quot;
Nothing
</code></pre>
<p>Try lifting some other functions of various numbers of arguments over <code>Maybe</code> in this way.</p>
<p>Alternatively <em>applicative do notation</em> can be used for the same purpose in a way that looks similar to the familiar <em>do notation</em>. Here is <code>lift3</code> using <em>applicative do notation</em>. Note <code>ado</code> is used instead of <code>do</code>, and <code>in</code> is used on the final line to denote the yielded value: </p>
<pre><code class="language-haskell">lift3 :: forall a b c d f
       . Apply f
      =&gt; (a -&gt; b -&gt; c -&gt; d)
      -&gt; f a
      -&gt; f b
      -&gt; f c
      -&gt; f d
lift3 f x y z = ado
  a &lt;- x
  b &lt;- y
  c &lt;- z
  in f a b c
</code></pre>
<h2><a class="header" href="#the-applicative-type-class" id="the-applicative-type-class">The Applicative Type Class</a></h2>
<p>There is a related type class called <code>Applicative</code>, defined as follows:</p>
<pre><code class="language-haskell">class Apply f &lt;= Applicative f where
  pure :: forall a. a -&gt; f a
</code></pre>
<p><code>Applicative</code> is a subclass of <code>Apply</code> and defines the <code>pure</code> function. <code>pure</code> takes a value and returns a value whose type has been wrapped with the type constructor <code>f</code>.</p>
<p>Here is the <code>Applicative</code> instance for <code>Maybe</code>:</p>
<pre><code class="language-haskell">instance applicativeMaybe :: Applicative Maybe where
  pure x = Just x
</code></pre>
<p>If we think of applicative functors as functors which allow lifting of functions, then <code>pure</code> can be thought of as lifting functions of zero arguments.</p>
<h2><a class="header" href="#intuition-for-applicative" id="intuition-for-applicative">Intuition for Applicative</a></h2>
<p>Functions in PureScript are pure and do not support side-effects. Applicative functors allow us to work in larger &quot;programming languages&quot; which support some sort of side-effect encoded by the functor <code>f</code>.</p>
<p>As an example, the functor <code>Maybe</code> represents the side effect of possibly-missing values. Some other examples include <code>Either err</code>, which represents the side effect of possible errors of type <code>err</code>, and the arrow functor <code>r -&gt;</code> which represents the side-effect of reading from a global configuration. For now, we'll only consider the <code>Maybe</code> functor.</p>
<p>If the functor <code>f</code> represents this larger programming language with effects, then the <code>Apply</code> and <code>Applicative</code> instances allow us to lift values and function applications from our smaller programming language (PureScript) into the new language.</p>
<p><code>pure</code> lifts pure (side-effect free) values into the larger language, and for functions, we can use <code>map</code> and <code>apply</code> as described above.</p>
<p>This raises a question: if we can use <code>Applicative</code> to embed PureScript functions and values into this new language, then how is the new language any larger? The answer depends on the functor <code>f</code>. If we can find expressions of type <code>f a</code> which cannot be expressed as <code>pure x</code> for some <code>x</code>, then that expression represents a term which only exists in the larger language.</p>
<p>When <code>f</code> is <code>Maybe</code>, an example is the expression <code>Nothing</code>: we cannot write <code>Nothing</code> as <code>pure x</code> for any <code>x</code>. Therefore, we can think of PureScript as having been enlarged to include the new term <code>Nothing</code>, which represents a missing value.</p>
<h2><a class="header" href="#more-effects" id="more-effects">More Effects</a></h2>
<p>Let's see some more examples of lifting functions over different <code>Applicative</code> functors.</p>
<p>Here is a simple example function defined in PSCi, which joins three names to form a full name:</p>
<pre><code class="language-text">&gt; import Prelude

&gt; fullName first middle last = last &lt;&gt; &quot;, &quot; &lt;&gt; first &lt;&gt; &quot; &quot; &lt;&gt; middle

&gt; fullName &quot;Phillip&quot; &quot;A&quot; &quot;Freeman&quot;
Freeman, Phillip A
</code></pre>
<p>Now suppose that this function forms the implementation of a (very simple!) web service with the three arguments provided as query parameters. We want to make sure that the user provided each of the three parameters, so we might use the <code>Maybe</code> type to indicate the presence or otherwise absence of a parameter. We can lift <code>fullName</code> over <code>Maybe</code> to create an implementation of the web service which checks for missing parameters:</p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Just &quot;A&quot; &lt;*&gt; Just &quot;Freeman&quot;
Just (&quot;Freeman, Phillip A&quot;)

&gt; fullName &lt;$&gt; Just &quot;Phillip&quot; &lt;*&gt; Nothing &lt;*&gt; Just &quot;Freeman&quot;
Nothing
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; import Data.Maybe

&gt; :paste… 
… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Just &quot;A&quot;
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
(Just &quot;Freeman, Phillip A&quot;)

… ado
…   f &lt;- Just &quot;Phillip&quot;
…   m &lt;- Nothing
…   l &lt;- Just &quot;Freeman&quot;
…   in fullName f m l
… ^D
Nothing
</code></pre>
<p>Note that the lifted function returns <code>Nothing</code> if any of the arguments was <code>Nothing</code>.</p>
<p>This is good, because now we can send an error response back from our web service if the parameters are invalid. However, it would be better if we could indicate which field was incorrect in the response.</p>
<p>Instead of lifting over <code>Maybe</code>, we can lift over <code>Either String</code>, which allows us to return an error message. First, let's write an operator to convert optional inputs into computations which can signal an error using <code>Either String</code>:</p>
<pre><code class="language-text">&gt; import Data.Either
&gt; :paste
… withError Nothing  err = Left err
… withError (Just a) _   = Right a
… ^D
</code></pre>
<p><em>Note</em>: In the <code>Either err</code> applicative functor, the <code>Left</code> constructor indicates an error, and the <code>Right</code> constructor indicates success.</p>
<p>Now we can lift over <code>Either String</code>, providing an appropriate error message for each parameter:</p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last =
…   fullName &lt;$&gt; (first  `withError` &quot;First name was missing&quot;)
…            &lt;*&gt; (middle `withError` &quot;Middle name was missing&quot;)
…            &lt;*&gt; (last   `withError` &quot;Last name was missing&quot;)
… ^D
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-text">&gt; :paste
… fullNameEither first middle last = ado 
…  f &lt;- first  `withError` &quot;First name was missing&quot;
…  m &lt;- middle `withError` &quot;Middle name was missing&quot;
…  l &lt;- last   `withError` &quot;Last name was missing&quot;
…  in fullName f m l
… ^D

&gt; :type fullNameEither
Maybe String -&gt; Maybe String -&gt; Maybe String -&gt; Either String String
</code></pre>
<p>Now our function takes three optional arguments using <code>Maybe</code>, and returns either a <code>String</code> error message or a <code>String</code> result.</p>
<p>We can try out the function with different inputs:</p>
<pre><code class="language-text">&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) (Just &quot;Freeman&quot;)
(Right &quot;Freeman, Phillip A&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) Nothing (Just &quot;Freeman&quot;)
(Left &quot;Middle name was missing&quot;)

&gt; fullNameEither (Just &quot;Phillip&quot;) (Just &quot;A&quot;) Nothing
(Left &quot;Last name was missing&quot;)
</code></pre>
<p>In this case, we see the error message corresponding to the first missing field, or a successful result if every field was provided. However, if we are missing multiple inputs, we still only see the first error:</p>
<pre><code class="language-text">&gt; fullNameEither Nothing Nothing Nothing
(Left &quot;First name was missing&quot;)
</code></pre>
<p>This might be good enough, but if we want to see a list of <em>all</em> missing fields in the error, then we need something more powerful than <code>Either String</code>. We will see a solution later in this chapter.</p>
<h2><a class="header" href="#combining-effects" id="combining-effects">Combining Effects</a></h2>
<p>As an example of working with applicative functors abstractly, this section will show how to write a function which will generically combine side-effects encoded by an applicative functor <code>f</code>.</p>
<p>What does this mean? Well, suppose we have a list of wrapped arguments of type <code>f a</code> for some <code>a</code>. That is, suppose we have an list of type <code>List (f a)</code>. Intuitively, this represents a list of computations with side-effects tracked by <code>f</code>, each with return type <code>a</code>. If we could run all of these computations in order, we would obtain a list of results of type <code>List a</code>. However, we would still have side-effects tracked by <code>f</code>. That is, we expect to be able to turn something of type <code>List (f a)</code> into something of type <code>f (List a)</code> by &quot;combining&quot; the effects inside the original list.</p>
<p>For any fixed list size <code>n</code>, there is a function of <code>n</code> arguments which builds a list of size <code>n</code> out of those arguments. For example, if <code>n</code> is <code>3</code>, the function is <code>\x y z -&gt; x : y : z : Nil</code>. This function has type <code>a -&gt; a -&gt; a -&gt; List a</code>. We can use the <code>Applicative</code> instance for <code>List</code> to lift this function over <code>f</code>, to get a function of type <code>f a -&gt; f a -&gt; f a -&gt; f (List a)</code>. But, since we can do this for any <code>n</code>, it makes sense that we should be able to perform the same lifting for any <em>list</em> of arguments.</p>
<p>That means that we should be able to write a function</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>This function will take a list of arguments, which possibly have side-effects, and return a single wrapped list, applying the side-effects of each.</p>
<p>To write this function, we'll consider the length of the list of arguments. If the list is empty, then we do not need to perform any effects, and we can use <code>pure</code> to simply return an empty list:</p>
<pre><code class="language-haskell">combineList Nil = pure Nil
</code></pre>
<p>In fact, this is the only thing we can do!</p>
<p>If the list is non-empty, then we have a head element, which is a wrapped argument of type <code>f a</code>, and a tail of type <code>List (f a)</code>. We can recursively combine the effects in the tail, giving a result of type <code>f (List a)</code>. We can then use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to lift the <code>Cons</code> constructor over the head and new tail:</p>
<pre><code class="language-haskell">combineList (Cons x xs) = Cons &lt;$&gt; x &lt;*&gt; combineList xs
</code></pre>
<p>Again, this was the only sensible implementation, based on the types we were given.</p>
<p>We can test this function in PSCi, using the <code>Maybe</code> type constructor as an example:</p>
<pre><code class="language-text">&gt; import Data.List
&gt; import Data.Maybe

&gt; combineList (fromFoldable [Just 1, Just 2, Just 3])
(Just (Cons 1 (Cons 2 (Cons 3 Nil))))

&gt; combineList (fromFoldable [Just 1, Nothing, Just 2])
Nothing
</code></pre>
<p>When specialized to <code>Maybe</code>, our function returns a <code>Just</code> only if every list element was <code>Just</code>, otherwise it returns <code>Nothing</code>. This is consistent with our intuition of working in a larger language supporting optional values - a list of computations which return optional results only has a result itself if every computation contained a result.</p>
<p>But the <code>combineList</code> function works for any <code>Applicative</code>! We can use it to combine computations which possibly signal an error using <code>Either err</code>, or which read from a global configuration using <code>r -&gt;</code>.</p>
<p>We will see the <code>combineList</code> function again later, when we consider <code>Traversable</code> functors.</p>
<h2><a class="header" href="#exercises" id="exercises">Exercises</a></h2>
<ol>
<li>(Easy) Use <code>lift2</code> to write lifted versions of the numeric operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> which work with optional arguments.</li>
<li>(Medium) Convince yourself that the definition of <code>lift3</code> given above in terms of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> does type check.</li>
<li>(Difficult) Write a function <code>combineMaybe</code> which has type <code>forall a f. Applicative f =&gt; Maybe (f a) -&gt; f (Maybe a)</code>. This function takes an optional computation with side-effects, and returns a side-effecting computation which has an optional result.</li>
</ol>
<h2><a class="header" href="#applicative-validation-1" id="applicative-validation-1">Applicative Validation</a></h2>
<p>The source code for this chapter defines several data types which might be used in an address book application. The details are omitted here, but the key functions which are exported by the <code>Data.AddressBook</code> module have the following types:</p>
<pre><code class="language-haskell">address :: String -&gt; String -&gt; String -&gt; Address

phoneNumber :: PhoneType -&gt; String -&gt; PhoneNumber

person :: String -&gt; String -&gt; Address -&gt; Array PhoneNumber -&gt; Person
</code></pre>
<p>where <code>PhoneType</code> is defined as an algebraic data type:</p>
<pre><code class="language-haskell">data PhoneType = HomePhone | WorkPhone | CellPhone | OtherPhone
</code></pre>
<p>These functions can be used to construct a <code>Person</code> representing an address book entry. For example, the following value is defined in <code>Data.AddressBook</code>:</p>
<pre><code class="language-haskell">examplePerson :: Person
examplePerson =
  person &quot;John&quot; &quot;Smith&quot;
         (address &quot;123 Fake St.&quot; &quot;FakeTown&quot; &quot;CA&quot;)
  	     [ phoneNumber HomePhone &quot;555-555-5555&quot;
         , phoneNumber CellPhone &quot;555-555-0000&quot;
  	     ]
</code></pre>
<p>Test this value in PSCi (this result has been formatted):</p>
<pre><code class="language-text">&gt; import Data.AddressBook

&gt; examplePerson
Person
  { firstName: &quot;John&quot;,
  , lastName: &quot;Smith&quot;,
  , address: Address
      { street: &quot;123 Fake St.&quot;
      , city: &quot;FakeTown&quot;
      , state: &quot;CA&quot;
      },
  , phones: [ PhoneNumber
                { type: HomePhone
                , number: &quot;555-555-5555&quot;
                }
            , PhoneNumber
                { type: CellPhone
                , number: &quot;555-555-0000&quot;
                }
            ]
  }  
</code></pre>
<p>We saw in a previous section how we could use the <code>Either String</code> functor to validate a data structure of type <code>Person</code>. For example, provided functions to validate the two names in the structure, we might validate the entire data structure as follows:</p>
<pre><code class="language-haskell">nonEmpty :: String -&gt; Either String Unit
nonEmpty &quot;&quot; = Left &quot;Field cannot be empty&quot;
nonEmpty _  = Right unit

validatePerson :: Person -&gt; Either String Person
validatePerson (Person o) =
  person &lt;$&gt; (nonEmpty o.firstName *&gt; pure o.firstName)
         &lt;*&gt; (nonEmpty o.lastName  *&gt; pure o.lastName)
         &lt;*&gt; pure o.address
         &lt;*&gt; pure o.phones
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; Either String Person
validatePersonAdo (Person o) = ado
  f &lt;- nonEmpty o.firstName *&gt; pure o.firstName
  l &lt;- nonEmpty o.lastName *&gt; pure o.firstName
  in person f l o.address o.phones
</code></pre>
<p>In the first two lines, we use the <code>nonEmpty</code> function to validate a non-empty string. <code>nonEmpty</code> returns an error (indicated with the <code>Left</code> constructor) if its input is empty, or a successful empty value (<code>unit</code>) using the <code>Right</code> constructor otherwise. We use the sequencing operator <code>*&gt;</code> to indicate that we want to perform two validations, returning the result from the validator on the right. In this case, the validator on the right simply uses <code>pure</code> to return the input unchanged.</p>
<p>The final lines do not perform any validation but simply provide the <code>address</code> and <code>phones</code> fields to the <code>person</code> function as the remaining arguments.</p>
<p>This function can be seen to work in PSCi, but has a limitation which we have seen before:</p>
<pre><code class="language-haskell">&gt; validatePerson $ person &quot;&quot; &quot;&quot; (address &quot;&quot; &quot;&quot; &quot;&quot;) []
(Left &quot;Field cannot be empty&quot;)
</code></pre>
<p>The <code>Either String</code> applicative functor only provides the first error encountered. Given the input here, we would prefer to see two errors - one for the missing first name, and a second for the missing last name.</p>
<p>There is another applicative functor which is provided by the <code>validation</code> library. This functor is called <code>V</code>, and it provides the ability to return errors in any <em>semigroup</em>. For example, we can use <code>V (Array String)</code> to return an array of <code>String</code>s as errors, concatenating new errors onto the end of the array.</p>
<p>The <code>Data.AddressBook.Validation</code> module uses the <code>V (Array String)</code> applicative functor to validate the data structures in the <code>Data.AddressBook</code> module.</p>
<p>Here is an example of a validator taken from the <code>Data.AddressBook.Validation</code> module:</p>
<pre><code class="language-haskell">type Errors = Array String

nonEmpty :: String -&gt; String -&gt; V Errors Unit
nonEmpty field &quot;&quot; = invalid [&quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' cannot be empty&quot;]
nonEmpty _     _  = pure unit

lengthIs :: String -&gt; Int -&gt; String -&gt; V Errors Unit
lengthIs field len value | S.length value /= len =
  invalid [&quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must have length &quot; &lt;&gt; show len]
lengthIs _     _   _     =
  pure unit

validateAddress :: Address -&gt; V Errors Address
validateAddress (Address o) =
  address &lt;$&gt; (nonEmpty &quot;Street&quot; o.street *&gt; pure o.street)
          &lt;*&gt; (nonEmpty &quot;City&quot;   o.city   *&gt; pure o.city)
          &lt;*&gt; (lengthIs &quot;State&quot; 2 o.state *&gt; pure o.state)
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validateAddressAdo :: Address -&gt; V Errors Address
validateAddressAdo (Address o) = ado
  street  &lt;- (nonEmpty &quot;Street&quot; o.street *&gt; pure o.street)
  city    &lt;- (nonEmpty &quot;City&quot;   o.city   *&gt; pure o.city)
  state   &lt;- (lengthIs &quot;State&quot; 2 o.state *&gt; pure o.state)
  in address street city state
</code></pre>
<p><code>validateAddress</code> validates an <code>Address</code> structure. It checks that the <code>street</code> and <code>city</code> fields are non-empty, and checks that the string in the <code>state</code> field has length 2.</p>
<p>Notice how the <code>nonEmpty</code> and <code>lengthIs</code> validator functions both use the <code>invalid</code> function provided by the <code>Data.Validation</code> module to indicate an error. Since we are working in the <code>Array String</code> semigroup, <code>invalid</code> takes an array of strings as its argument.</p>
<p>We can try this function in PSCi:</p>
<pre><code class="language-text">&gt; import Data.AddressBook
&gt; import Data.AddressBook.Validation

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;&quot;
(Invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         , &quot;Field 'State' must have length 2&quot;
         ])

&gt; validateAddress $ address &quot;&quot; &quot;&quot; &quot;CA&quot;
(Invalid [ &quot;Field 'Street' cannot be empty&quot;
         , &quot;Field 'City' cannot be empty&quot;
         ])
</code></pre>
<p>This time, we receive an array of all validation errors.</p>
<h2><a class="header" href="#regular-expression-validators" id="regular-expression-validators">Regular Expression Validators</a></h2>
<p>The <code>validatePhoneNumber</code> function uses a regular expression to validate the form of its argument. The key is a <code>matches</code> validation function, which uses a <code>Regex</code> from the <code>Data.String.Regex</code> module to validate its input:</p>
<pre><code class="language-haskell">matches :: String -&gt; R.Regex -&gt; String -&gt; V Errors Unit
matches _     regex value | R.test regex value =
  pure unit
matches field _     _     =
  invalid [&quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' did not match the required format&quot;]
</code></pre>
<p>Again, notice how <code>pure</code> is used to indicate successful validation, and <code>invalid</code> is used to signal an array of errors.</p>
<p><code>validatePhoneNumber</code> is built from the <code>matches</code> function in the same way as before:</p>
<pre><code class="language-haskell">validatePhoneNumber :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumber (PhoneNumber o) =
  phoneNumber &lt;$&gt; pure o.&quot;type&quot;
              &lt;*&gt; (matches &quot;Number&quot; phoneNumberRegex o.number *&gt; pure o.number)
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePhoneNumberAdo :: PhoneNumber -&gt; V Errors PhoneNumber
validatePhoneNumberAdo (PhoneNumber o) = ado
  tpe     &lt;-  pure o.&quot;type&quot;
  number  &lt;-  (matches &quot;Number&quot; phoneNumberRegex o.number *&gt; pure o.number)
  in phoneNumber tpe number
</code></pre>
<p>Again, try running this validator against some valid and invalid inputs in PSCi:</p>
<pre><code class="language-text">&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555-555-5555&quot;
Valid (PhoneNumber { type: HomePhone, number: &quot;555-555-5555&quot; })

&gt; validatePhoneNumber $ phoneNumber HomePhone &quot;555.555.5555&quot;
Invalid ([&quot;Field 'Number' did not match the required format&quot;])
</code></pre>
<h2><a class="header" href="#exercises-1" id="exercises-1">Exercises</a></h2>
<ol>
<li>(Easy) Use a regular expression validator to ensure that the <code>state</code> field of the <code>Address</code> type contains two alphabetic characters. <em>Hint</em>: see the source code for <code>phoneNumberRegex</code>.</li>
<li>(Medium) Using the <code>matches</code> validator, write a validation function which checks that a string is not entirely whitespace. Use it to replace <code>nonEmpty</code> where appropriate.</li>
</ol>
<h2><a class="header" href="#traversable-functors" id="traversable-functors">Traversable Functors</a></h2>
<p>The remaining validator is <code>validatePerson</code>, which combines the validators we have seen so far to validate an entire <code>Person</code> structure:</p>
<pre><code class="language-haskell">arrayNonEmpty :: forall a. String -&gt; Array a -&gt; V Errors Unit
arrayNonEmpty field [] =
  invalid [&quot;Field '&quot; &lt;&gt; field &lt;&gt; &quot;' must contain at least one value&quot;]
arrayNonEmpty _     _  =
  pure unit

validatePerson :: Person -&gt; V Errors Person
validatePerson (Person o) =
  person &lt;$&gt; (nonEmpty &quot;First Name&quot; o.firstName *&gt;
              pure o.firstName)
         &lt;*&gt; (nonEmpty &quot;Last Name&quot;  o.lastName  *&gt;
              pure o.lastName)
	       &lt;*&gt; validateAddress o.address
         &lt;*&gt; (arrayNonEmpty &quot;Phone Numbers&quot; o.phones *&gt;
              traverse validatePhoneNumber o.phones)
</code></pre>
<p>or with <em>applicative do</em></p>
<pre><code class="language-haskell">validatePersonAdo :: Person -&gt; V Errors Person
validatePersonAdo (Person o) = ado
  firstName   &lt;- (nonEmpty &quot;First Name&quot; o.firstName *&gt; 
                  pure o.firstName)
  lastName    &lt;- (nonEmpty &quot;Last Name&quot;  o.lastName  *&gt; 
                  pure o.lastName)
  address     &lt;- validateAddress o.address
  numbers     &lt;- (arrayNonEmpty &quot;Phone Numbers&quot; o.phones *&gt; 
                  traverse validatePhoneNumber o.phones)
  in person firstName lastName address numbers
</code></pre>
<p>There is one more interesting function here, which we haven't seen yet - <code>traverse</code>, which appears in the final line.</p>
<p><code>traverse</code> is defined in the <code>Data.Traversable</code> module, in the <code>Traversable</code> type class:</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) &lt;= Traversable t where
  traverse :: forall a b f. Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
  sequence :: forall a f. Applicative f =&gt; t (f a) -&gt; f (t a)
</code></pre>
<p><code>Traversable</code> defines the class of <em>traversable functors</em>. The types of its functions might look a little intimidating, but <code>validatePerson</code> provides a good motivating example.</p>
<p>Every traversable functor is both a <code>Functor</code> and <code>Foldable</code> (recall that a <em>foldable functor</em> was a type constructor which supported a fold operation, reducing a structure to a single value). In addition, a traversable functor provides the ability to combine a collection of side-effects which depend on its structure.</p>
<p>This may sound complicated, but let's simplify things by specializing to the case of arrays. The array type constructor is traversable, which means that there is a function:</p>
<pre><code class="language-haskell">traverse :: forall a b f. Applicative f =&gt; (a -&gt; f b) -&gt; Array a -&gt; f (Array b)
</code></pre>
<p>Intuitively, given any applicative functor <code>f</code>, and a function which takes a value of type <code>a</code> and returns a value of type <code>b</code> (with side-effects tracked by <code>f</code>), we can apply the function to each element of an array of type <code>Array a</code> to obtain a result of type <code>Array b</code> (with side-effects tracked by <code>f</code>).</p>
<p>Still not clear? Let's specialize further to the case where <code>m</code> is the <code>V Errors</code> applicative functor above. Now, we have a function of type</p>
<pre><code class="language-haskell">traverse :: forall a b. (a -&gt; V Errors b) -&gt; Array a -&gt; V Errors (Array b)
</code></pre>
<p>This type signature says that if we have a validation function <code>f</code> for a type <code>a</code>, then <code>traverse f</code> is a validation function for arrays of type <code>Array a</code>. But that's exactly what we need to be able to validate the <code>phones</code> field of the <code>Person</code> data structure! We pass <code>validatePhoneNumber</code> to <code>traverse</code> to create a validation function which validates each element successively.</p>
<p>In general, <code>traverse</code> walks over the elements of a data structure, performing computations with side-effects and accumulating a result.</p>
<p>The type signature for <code>Traversable</code>'s other function <code>sequence</code> might look more familiar:</p>
<pre><code class="language-haskell">sequence :: forall a f. Applicative f =&gt; t (f a) -&gt; f (t a)
</code></pre>
<p>In fact, the <code>combineList</code> function that we wrote earlier is just a special case of the <code>sequence</code> function from the <code>Traversable</code> type class. Setting <code>t</code> to be the type constructor <code>List</code>, we recover the type of the <code>combineList</code> function:</p>
<pre><code class="language-haskell">combineList :: forall f a. Applicative f =&gt; List (f a) -&gt; f (List a)
</code></pre>
<p>Traversable functors capture the idea of traversing a data structure, collecting a set of effectful computations, and combining their effects. In fact, <code>sequence</code> and <code>traverse</code> are equally important to the definition of <code>Traversable</code> - each can be implemented in terms of each other. This is left as an exercise for the interested reader.</p>
<p>The <code>Traversable</code> instance for lists is given in the <code>Data.List</code> module. The definition of <code>traverse</code> is given here:</p>
<pre><code class="language-haskell">-- traverse :: forall a b f. Applicative f =&gt; (a -&gt; f b) -&gt; List a -&gt; f (List b)
traverse _ Nil = pure Nil
traverse f (Cons x xs) = Cons &lt;$&gt; f x &lt;*&gt; traverse f xs
</code></pre>
<p>In the case of an empty list, we can simply return an empty list using <code>pure</code>. If the list is non-empty, we can use the function <code>f</code> to create a computation of type <code>f b</code> from the head element. We can also call <code>traverse</code> recursively on the tail. Finally, we can lift the <code>Cons</code> constructor over the applicative functor <code>f</code> to combine the two results.</p>
<p>But there are more examples of traversable functors than just arrays and lists. The <code>Maybe</code> type constructor we saw earlier also has an instance for <code>Traversable</code>. We can try it in PSCi:</p>
<pre><code class="language-text">&gt; import Data.Maybe
&gt; import Data.Traversable

&gt; traverse (nonEmpty &quot;Example&quot;) Nothing
(Valid Nothing)

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;&quot;)
(Invalid [&quot;Field 'Example' cannot be empty&quot;])

&gt; traverse (nonEmpty &quot;Example&quot;) (Just &quot;Testing&quot;)
(Valid (Just unit))
</code></pre>
<p>These examples show that traversing the <code>Nothing</code> value returns <code>Nothing</code> with no validation, and traversing <code>Just x</code> uses the validation function to validate <code>x</code>. That is, <code>traverse</code> takes a validation function for type <code>a</code> and returns a validation function for <code>Maybe a</code>, i.e. a validation function for optional values of type <code>a</code>.</p>
<p>Other traversable functors include <code>Array</code>, and <code>Tuple a</code> and <code>Either a</code> for any type <code>a</code>. Generally, most &quot;container&quot; data type constructors have <code>Traversable</code> instances. As an example, the exercises will include writing a <code>Traversable</code> instance for a type of binary trees.</p>
<h2><a class="header" href="#exercises-2" id="exercises-2">Exercises</a></h2>
<ol>
<li>
<p>(Medium) Write a <code>Traversable</code> instance for the following binary tree data structure, which combines side-effects from left-to-right:</p>
<pre><code class="language-haskell">data Tree a = Leaf | Branch (Tree a) a (Tree a)
</code></pre>
<p>This corresponds to an in-order traversal of the tree. What about a preorder traversal? What about reverse order?</p>
</li>
<li>
<p>(Medium) Modify the code to make the <code>address</code> field of the <code>Person</code> type optional using <code>Data.Maybe</code>. <em>Hint</em>: Use <code>traverse</code> to validate a field of type <code>Maybe a</code>.</p>
</li>
<li>
<p>(Difficult) Try to write <code>sequence</code> in terms of <code>traverse</code>. Can you write <code>traverse</code> in terms of <code>sequence</code>?</p>
</li>
</ol>
<h2><a class="header" href="#applicative-functors-for-parallelism" id="applicative-functors-for-parallelism">Applicative Functors for Parallelism</a></h2>
<p>In the discussion above, I chose the word &quot;combine&quot; to describe how applicative functors &quot;combine side-effects&quot;. However, in all the examples given, it would be equally valid to say that applicative functors allow us to &quot;sequence&quot; effects. This would be consistent with the intuition that traversable functors provide a <code>sequence</code> function to combine effects in sequence based on a data structure.</p>
<p>However, in general, applicative functors are more general than this. The applicative functor laws do not impose any ordering on the side-effects that their computations perform. In fact, it would be valid for an applicative functor to perform its side-effects in parallel.</p>
<p>For example, the <code>V</code> validation functor returned an <em>array</em> of errors, but it would work just as well if we picked the <code>Set</code> semigroup, in which case it would not matter what order we ran the various validators. We could even run them in parallel over the data structure!</p>
<p>As a second example, the <code>parallel</code> package provides a type class <code>Parallel</code> which supports <em>parallel computations</em>. <code>Parallel</code> provides a function <code>parallel</code> which uses some <code>Applicative</code> functor to compute the result of its input computation <em>in parallel</em>:</p>
<pre><code class="language-haskell">f &lt;$&gt; parallel computation1
  &lt;*&gt; parallel computation2
</code></pre>
<p>This computation would start computing values asynchronously using <code>computation1</code> and <code>computation2</code>. When both results have been computed, they would be combined into a single result using the function <code>f</code>.</p>
<p>We will see this idea in more detail when we apply applicative functors to the problem of <em>callback hell</em> later in the book.</p>
<p>Applicative functors are a natural way to capture side-effects which can be combined in parallel.</p>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>In this chapter, we covered a lot of new ideas:</p>
<ul>
<li>We introduced the concept of an <em>applicative functor</em> which generalizes the idea of function application to type constructors which capture some notion of side-effect.</li>
<li>We saw how applicative functors gave a solution to the problem of validating data structures, and how by switching the applicative functor we could change from reporting a single error to reporting all errors across a data structure.</li>
<li>We met the <code>Traversable</code> type class, which encapsulates the idea of a <em>traversable functor</em>, or a container whose elements can be used to combine values with side-effects.</li>
</ul>
<p>Applicative functors are an interesting abstraction which provide neat solutions to a number of problems. We will see them a few more times throughout the book. In this case, the validation applicative functor provided a way to write validators in a declarative style, allowing us to define <em>what</em> our validators should validate and not <em>how</em> they should perform that validation. In general, we will see that applicative functors are a useful tool for the design of <em>domain specific languages</em>.</p>
<p>In the next chapter, we will see a related idea, the class of <em>monads</em>, and extend our address book example to run in the browser!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter6.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter8.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter6.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter8.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
